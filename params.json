{"name":"Favoriteplaces","tagline":"","body":"<!DOCTYPE html>\r\n<html>\r\n<head>\r\n<meta charset=utf-8 />\r\n<title>My Favorite Places</title>\r\n<meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />\r\n<script src='https://api.tiles.mapbox.com/mapbox.js/v2.2.1/mapbox.js'></script>\r\n<link href='https://api.tiles.mapbox.com/mapbox.js/v2.2.1/mapbox.css' rel='stylesheet'/>\r\n<script src=\"tabletop.js\"></script>\r\n<script src=\"script.js\"></script>\r\n<script text = \"text/javascript\">\r\n\r\n\r\nwindow.onload = function() {init()};\r\n\r\nvar public_spreadsheet_url = 'https://docs.google.com/spreadsheets/d/1do7tk5K9yhNlAx8wVda-4pU2hvGNF1D5AkgduLovcMw/pubhtml';\r\n\r\nfunction init(){\r\n\tTabletop.init( {key: public_spreadsheet_url,\r\n\t\t\t\t\tcallback: showInfo,\r\n\t\t\t\t\tsimpleSheet: true } )\r\n}\r\n\r\nfunction showInfo(data, tabletop) {\r\n\t//alert (\"successfully processed!\")\r\n\tconsole.log(data);\r\n\t}\r\n</script>\t\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<style>\r\n  body { margin:0; padding:0; }\r\n  #map { position:absolute; top:0; bottom:0; width:100%; }\r\n</style>\r\n</head>\r\n<body>\r\n\r\n<style>\r\n//.leaflet-popup-content img{\r\n//\tmax-width: 100%;\r\n//\t}\r\n</style>\r\n<div id='map'></div>\r\n\r\n<script>\r\nL.mapbox.accessToken = 'pk.eyJ1IjoiaGFubmFobGVlIiwiYSI6IjMxZWY0MDA2OTRkYTMzM2Y2OWUwNjE1YWMyNDM4MDk3In0.guMen29AvvMq9jY2uFSd3g';\r\n\r\nvar map = L.mapbox.map('map', 'mapbox.streets')\r\n    //.addLayer(mapboxTiles)\r\n    .setView([41.8781136, -87.629798], 14);\r\n    \r\nvar myLayer=L.mapbox.featureLayer().addTo(map);\r\n\r\n\r\nmyLayer.on('layeradd', function(e){\r\n\tvar marker = e.layer,\r\n\t\tfeature = marker.feature;\r\n\t\t\r\n\tvar popupContent = '<h2>' + feature.properties.tile+ '</h2>' + '<p>'+ feature.properties.description+'</p>'+ '<a target = \"_blank\" class = \"popup\" href = \"' + feature.properties.url + '\">'\r\n\t\t\t\t\t\t//+'<img src = \"' + feature.properties.image + '\"width = \"150px\"/>'\r\n\t\t\t\t\t\t\r\n\tmarker.bindPopup(popupContent, {\r\n\t\tcloseButton: false,\r\n\t\tminWidth: 320\r\n\t\t});\r\n});\r\n\t\t\t\t\t\t\t\t\t\t\t\r\n</script>\r\n<script>\r\n(function(global) {\r\n  \"use strict\";\r\n\r\n  var inNodeJS = false;\r\n  if (typeof module !== 'undefined' && module.exports) {\r\n    inNodeJS = true;\r\n    var request = require('request');\r\n  }\r\n\r\n  var supportsCORS = false;\r\n  var inLegacyIE = false;\r\n  try {\r\n    var testXHR = new XMLHttpRequest();\r\n    if (typeof testXHR.withCredentials !== 'undefined') {\r\n      supportsCORS = true;\r\n    } else {\r\n      if (\"XDomainRequest\" in window) {\r\n        supportsCORS = true;\r\n        inLegacyIE = true;\r\n      }\r\n    }\r\n  } catch (e) { }\r\n\r\n  // Create a simple indexOf function for support\r\n  // of older browsers.  Uses native indexOf if \r\n  // available.  Code similar to underscores.\r\n  // By making a separate function, instead of adding\r\n  // to the prototype, we will not break bad for loops\r\n  // in older browsers\r\n  var indexOfProto = Array.prototype.indexOf;\r\n  var ttIndexOf = function(array, item) {\r\n    var i = 0, l = array.length;\r\n    \r\n    if (indexOfProto && array.indexOf === indexOfProto) return array.indexOf(item);\r\n    for (; i < l; i++) if (array[i] === item) return i;\r\n    return -1;\r\n  };\r\n  \r\n  /*\r\n    Initialize with Tabletop.init( { key: '0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc' } )\r\n      OR!\r\n    Initialize with Tabletop.init( { key: 'https://docs.google.com/spreadsheet/pub?hl=en_US&hl=en_US&key=0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc&output=html&widget=true' } )\r\n      OR!\r\n    Initialize with Tabletop.init('0AjAPaAU9MeLFdHUxTlJiVVRYNGRJQnRmSnQwTlpoUXc')\r\n  */\r\n\r\n  var Tabletop = function(options) {\r\n    // Make sure Tabletop is being used as a constructor no matter what.\r\n    if(!this || !(this instanceof Tabletop)) {\r\n      return new Tabletop(options);\r\n    }\r\n    \r\n    if(typeof(options) === 'string') {\r\n      options = { key : options };\r\n    }\r\n\r\n    this.callback = options.callback;\r\n    this.wanted = options.wanted || [];\r\n    this.key = options.key;\r\n    this.simpleSheet = !!options.simpleSheet;\r\n    this.parseNumbers = !!options.parseNumbers;\r\n    this.wait = !!options.wait;\r\n    this.reverse = !!options.reverse;\r\n    this.postProcess = options.postProcess;\r\n    this.debug = !!options.debug;\r\n    this.query = options.query || '';\r\n    this.orderby = options.orderby;\r\n    this.endpoint = options.endpoint || \"https://spreadsheets.google.com\";\r\n    this.singleton = !!options.singleton;\r\n    this.simple_url = !!options.simple_url;\r\n    this.callbackContext = options.callbackContext;\r\n    // Default to on, unless there's a proxy, in which case it's default off\r\n    this.prettyColumnNames = typeof(options.prettyColumnNames) == 'undefined' ? !options.proxy : options.prettyColumnNames\r\n    \r\n    if(typeof(options.proxy) !== 'undefined') {\r\n      // Remove trailing slash, it will break the app\r\n      this.endpoint = options.proxy.replace(/\\/$/,'');\r\n      this.simple_url = true;\r\n      this.singleton = true;\r\n      // Let's only use CORS (straight JSON request) when\r\n      // fetching straight from Google\r\n      supportsCORS = false;\r\n    }\r\n    \r\n    this.parameterize = options.parameterize || false;\r\n    \r\n    if(this.singleton) {\r\n      if(typeof(Tabletop.singleton) !== 'undefined') {\r\n        this.log(\"WARNING! Tabletop singleton already defined\");\r\n      }\r\n      Tabletop.singleton = this;\r\n    }\r\n    \r\n    /* Be friendly about what you accept */\r\n    if(/key=/.test(this.key)) {\r\n      this.log(\"You passed an old Google Docs url as the key! Attempting to parse.\");\r\n      this.key = this.key.match(\"key=(.*?)(&|#|$)\")[1];\r\n    }\r\n\r\n    if(/pubhtml/.test(this.key)) {\r\n      this.log(\"You passed a new Google Spreadsheets url as the key! Attempting to parse.\");\r\n      this.key = this.key.match(\"d\\\\/(.*?)\\\\/pubhtml\")[1];\r\n    }\r\n\r\n    if(!this.key) {\r\n      this.log(\"You need to pass Tabletop a key!\");\r\n      return;\r\n    }\r\n\r\n    this.log(\"Initializing with key \" + this.key);\r\n\r\n    this.models = {};\r\n    this.model_names = [];\r\n\r\n    this.base_json_path = \"/feeds/worksheets/\" + this.key + \"/public/basic?alt=\";\r\n\r\n    if (inNodeJS || supportsCORS) {\r\n      this.base_json_path += 'json';\r\n    } else {\r\n      this.base_json_path += 'json-in-script';\r\n    }\r\n    \r\n    if(!this.wait) {\r\n      this.fetch();\r\n    }\r\n  };\r\n\r\n  // A global storage for callbacks.\r\n  Tabletop.callbacks = {};\r\n\r\n  // Backwards compatibility.\r\n  Tabletop.init = function(options) {\r\n    return new Tabletop(options);\r\n  };\r\n\r\n  Tabletop.sheets = function() {\r\n    this.log(\"Times have changed! You'll want to use var tabletop = Tabletop.init(...); tabletop.sheets(...); instead of Tabletop.sheets(...)\");\r\n  };\r\n\r\n  Tabletop.prototype = {\r\n\r\n    fetch: function(callback) {\r\n      if(typeof(callback) !== \"undefined\") {\r\n        this.callback = callback;\r\n      }\r\n      this.requestData(this.base_json_path, this.loadSheets);\r\n    },\r\n    \r\n    /*\r\n      This will call the environment appropriate request method.\r\n      \r\n      In browser it will use JSON-P, in node it will use request()\r\n    */\r\n    requestData: function(path, callback) {\r\n      if (inNodeJS) {\r\n        this.serverSideFetch(path, callback);\r\n      } else {\r\n        //CORS only works in IE8/9 across the same protocol\r\n        //You must have your server on HTTPS to talk to Google, or it'll fall back on injection\r\n        var protocol = this.endpoint.split(\"//\").shift() || \"http\";\r\n        if (supportsCORS && (!inLegacyIE || protocol === location.protocol)) {\r\n          this.xhrFetch(path, callback);\r\n        } else {\r\n          this.injectScript(path, callback);\r\n        }\r\n      }\r\n    },\r\n\r\n    /*\r\n      Use Cross-Origin XMLHttpRequest to get the data in browsers that support it.\r\n    */\r\n    xhrFetch: function(path, callback) {\r\n      //support IE8's separate cross-domain object\r\n      var xhr = inLegacyIE ? new XDomainRequest() : new XMLHttpRequest();\r\n      xhr.open(\"GET\", this.endpoint + path);\r\n      var self = this;\r\n      xhr.onload = function() {\r\n        try {\r\n          var json = JSON.parse(xhr.responseText);\r\n        } catch (e) {\r\n          console.error(e);\r\n        }\r\n        callback.call(self, json);\r\n      };\r\n      xhr.send();\r\n    },\r\n    \r\n    /*\r\n      Insert the URL into the page as a script tag. Once it's loaded the spreadsheet data\r\n      it triggers the callback. This helps you avoid cross-domain errors\r\n      http://code.google.com/apis/gdata/samples/spreadsheet_sample.html\r\n\r\n      Let's be plain-Jane and not use jQuery or anything.\r\n    */\r\n    injectScript: function(path, callback) {\r\n      var script = document.createElement('script');\r\n      var callbackName;\r\n      \r\n      if(this.singleton) {\r\n        if(callback === this.loadSheets) {\r\n          callbackName = 'Tabletop.singleton.loadSheets';\r\n        } else if (callback === this.loadSheet) {\r\n          callbackName = 'Tabletop.singleton.loadSheet';\r\n        }\r\n      } else {\r\n        var self = this;\r\n        callbackName = 'tt' + (+new Date()) + (Math.floor(Math.random()*100000));\r\n        // Create a temp callback which will get removed once it has executed,\r\n        // this allows multiple instances of Tabletop to coexist.\r\n        Tabletop.callbacks[ callbackName ] = function () {\r\n          var args = Array.prototype.slice.call( arguments, 0 );\r\n          callback.apply(self, args);\r\n          script.parentNode.removeChild(script);\r\n          delete Tabletop.callbacks[callbackName];\r\n        };\r\n        callbackName = 'Tabletop.callbacks.' + callbackName;\r\n      }\r\n      \r\n      var url = path + \"&callback=\" + callbackName;\r\n      \r\n      if(this.simple_url) {\r\n        // We've gone down a rabbit hole of passing injectScript the path, so let's\r\n        // just pull the sheet_id out of the path like the least efficient worker bees\r\n        if(path.indexOf(\"/list/\") !== -1) {\r\n          script.src = this.endpoint + \"/\" + this.key + \"-\" + path.split(\"/\")[4];\r\n        } else {\r\n          script.src = this.endpoint + \"/\" + this.key;\r\n        }\r\n      } else {\r\n        script.src = this.endpoint + url;\r\n      }\r\n      \r\n      if (this.parameterize) {\r\n        script.src = this.parameterize + encodeURIComponent(script.src);\r\n      }\r\n      \r\n      document.getElementsByTagName('script')[0].parentNode.appendChild(script);\r\n    },\r\n    \r\n    /* \r\n      This will only run if tabletop is being run in node.js\r\n    */\r\n    serverSideFetch: function(path, callback) {\r\n      var self = this\r\n      request({url: this.endpoint + path, json: true}, function(err, resp, body) {\r\n        if (err) {\r\n          return console.error(err);\r\n        }\r\n        callback.call(self, body);\r\n      });\r\n    },\r\n\r\n    /* \r\n      Is this a sheet you want to pull?\r\n      If { wanted: [\"Sheet1\"] } has been specified, only Sheet1 is imported\r\n      Pulls all sheets if none are specified\r\n    */\r\n    isWanted: function(sheetName) {\r\n      if(this.wanted.length === 0) {\r\n        return true;\r\n      } else {\r\n        return (ttIndexOf(this.wanted, sheetName) !== -1);\r\n      }\r\n    },\r\n    \r\n    /*\r\n      What gets send to the callback\r\n      if simpleSheet === true, then don't return an array of Tabletop.this.models,\r\n      only return the first one's elements\r\n    */\r\n    data: function() {\r\n      // If the instance is being queried before the data's been fetched\r\n      // then return undefined.\r\n      if(this.model_names.length === 0) {\r\n        return undefined;\r\n      }\r\n      if(this.simpleSheet) {\r\n        if(this.model_names.length > 1 && this.debug) {\r\n          this.log(\"WARNING You have more than one sheet but are using simple sheet mode! Don't blame me when something goes wrong.\");\r\n        }\r\n        return this.models[ this.model_names[0] ].all();\r\n      } else {\r\n        return this.models;\r\n      }\r\n    },\r\n\r\n    /*\r\n      Add another sheet to the wanted list\r\n    */\r\n    addWanted: function(sheet) {\r\n      if(ttIndexOf(this.wanted, sheet) === -1) {\r\n        this.wanted.push(sheet);\r\n      }\r\n    },\r\n    \r\n    /*\r\n      Load all worksheets of the spreadsheet, turning each into a Tabletop Model.\r\n      Need to use injectScript because the worksheet view that you're working from\r\n      doesn't actually include the data. The list-based feed (/feeds/list/key..) does, though.\r\n      Calls back to loadSheet in order to get the real work done.\r\n\r\n      Used as a callback for the worksheet-based JSON\r\n    */\r\n    loadSheets: function(data) {\r\n      var i, ilen;\r\n      var toLoad = [];\r\n      this.foundSheetNames = [];\r\n\r\n      for(i = 0, ilen = data.feed.entry.length; i < ilen ; i++) {\r\n        this.foundSheetNames.push(data.feed.entry[i].title.$t);\r\n        // Only pull in desired sheets to reduce loading\r\n        if( this.isWanted(data.feed.entry[i].content.$t) ) {\r\n          var linkIdx = data.feed.entry[i].link.length-1;\r\n          var sheet_id = data.feed.entry[i].link[linkIdx].href.split('/').pop();\r\n          var json_path = \"/feeds/list/\" + this.key + \"/\" + sheet_id + \"/public/values?alt=\"\r\n          if (inNodeJS || supportsCORS) {\r\n            json_path += 'json';\r\n          } else {\r\n            json_path += 'json-in-script';\r\n          }\r\n          if(this.query) {\r\n            json_path += \"&sq=\" + this.query;\r\n          }\r\n          if(this.orderby) {\r\n            json_path += \"&orderby=column:\" + this.orderby.toLowerCase();\r\n          }\r\n          if(this.reverse) {\r\n            json_path += \"&reverse=true\";\r\n          }\r\n          toLoad.push(json_path);\r\n        }\r\n      }\r\n\r\n      this.sheetsToLoad = toLoad.length;\r\n      for(i = 0, ilen = toLoad.length; i < ilen; i++) {\r\n        this.requestData(toLoad[i], this.loadSheet);\r\n      }\r\n    },\r\n\r\n    /*\r\n      Access layer for the this.models\r\n      .sheets() gets you all of the sheets\r\n      .sheets('Sheet1') gets you the sheet named Sheet1\r\n    */\r\n    sheets: function(sheetName) {\r\n      if(typeof sheetName === \"undefined\") {\r\n        return this.models;\r\n      } else {\r\n        if(typeof(this.models[ sheetName ]) === \"undefined\") {\r\n          // alert( \"Can't find \" + sheetName );\r\n          return;\r\n        } else {\r\n          return this.models[ sheetName ];\r\n        }\r\n      }\r\n    },\r\n\r\n    sheetReady: function(model) {\r\n      this.models[ model.name ] = model;\r\n      if(ttIndexOf(this.model_names, model.name) === -1) {\r\n        this.model_names.push(model.name);\r\n      }\r\n\r\n      this.sheetsToLoad--;\r\n      if(this.sheetsToLoad === 0)\r\n        this.doCallback();\r\n    },\r\n    \r\n    /*\r\n      Parse a single list-based worksheet, turning it into a Tabletop Model\r\n\r\n      Used as a callback for the list-based JSON\r\n    */\r\n    loadSheet: function(data) {\r\n      var that = this;\r\n      var model = new Tabletop.Model( { data: data, \r\n                                        parseNumbers: this.parseNumbers,\r\n                                        postProcess: this.postProcess,\r\n                                        tabletop: this,\r\n                                        prettyColumnNames: this.prettyColumnNames,\r\n                                        onReady: function() {\r\n                                          that.sheetReady(this);\r\n                                        } } );\r\n    },\r\n\r\n    /*\r\n      Execute the callback upon loading! Rely on this.data() because you might\r\n        only request certain pieces of data (i.e. simpleSheet mode)\r\n      Tests this.sheetsToLoad just in case a race condition happens to show up\r\n    */\r\n    doCallback: function() {\r\n      if(this.sheetsToLoad === 0) {\r\n        this.callback.apply(this.callbackContext || this, [this.data(), this]);\r\n      }\r\n    },\r\n\r\n    log: function(msg) {\r\n      if(this.debug) {\r\n        if(typeof console !== \"undefined\" && typeof console.log !== \"undefined\") {\r\n          Function.prototype.apply.apply(console.log, [console, arguments]);\r\n        }\r\n      }\r\n    }\r\n\r\n  };\r\n\r\n  /*\r\n    Tabletop.Model stores the attribute names and parses the worksheet data\r\n      to turn it into something worthwhile\r\n\r\n    Options should be in the format { data: XXX }, with XXX being the list-based worksheet\r\n  */\r\n  Tabletop.Model = function(options) {\r\n    var i, j, ilen, jlen;\r\n    this.column_names = [];\r\n    this.name = options.data.feed.title.$t;\r\n    this.tabletop = options.tabletop;\r\n    this.elements = [];\r\n    this.onReady = options.onReady;\r\n    this.raw = options.data; // A copy of the sheet's raw data, for accessing minutiae\r\n\r\n    if(typeof(options.data.feed.entry) === 'undefined') {\r\n      options.tabletop.log(\"Missing data for \" + this.name + \", make sure you didn't forget column headers\");\r\n      this.original_columns = [];\r\n      this.elements = [];\r\n      this.onReady.call(this);\r\n      return;\r\n    }\r\n    \r\n    for(var key in options.data.feed.entry[0]){\r\n      if(/^gsx/.test(key))\r\n        this.column_names.push( key.replace(\"gsx$\",\"\") );\r\n    }\r\n\r\n    this.original_columns = this.column_names;\r\n    \r\n    for(i = 0, ilen =  options.data.feed.entry.length ; i < ilen; i++) {\r\n      var source = options.data.feed.entry[i];\r\n      var element = {};\r\n      for(var j = 0, jlen = this.column_names.length; j < jlen ; j++) {\r\n        var cell = source[ \"gsx$\" + this.column_names[j] ];\r\n        if (typeof(cell) !== 'undefined') {\r\n          if(options.parseNumbers && cell.$t !== '' && !isNaN(cell.$t))\r\n            element[ this.column_names[j] ] = +cell.$t;\r\n          else\r\n            element[ this.column_names[j] ] = cell.$t;\r\n        } else {\r\n            element[ this.column_names[j] ] = '';\r\n        }\r\n      }\r\n      if(element.rowNumber === undefined)\r\n        element.rowNumber = i + 1;\r\n      if( options.postProcess )\r\n        options.postProcess(element);\r\n      this.elements.push(element);\r\n    }\r\n    \r\n    if(options.prettyColumnNames)\r\n      this.fetchPrettyColumns();\r\n    else\r\n      this.onReady.call(this);\r\n  };\r\n\r\n  Tabletop.Model.prototype = {\r\n    /*\r\n      Returns all of the elements (rows) of the worksheet as objects\r\n    */\r\n    all: function() {\r\n      return this.elements;\r\n    },\r\n    \r\n    fetchPrettyColumns: function() {\r\n      if(!this.raw.feed.link[3])\r\n        return this.ready();\r\n      var cellurl = this.raw.feed.link[3].href.replace('/feeds/list/', '/feeds/cells/').replace('https://spreadsheets.google.com', '');\r\n      var that = this;\r\n      this.tabletop.requestData(cellurl, function(data) {\r\n        that.loadPrettyColumns(data)\r\n      });\r\n    },\r\n    \r\n    ready: function() {\r\n      this.onReady.call(this);\r\n    },\r\n    \r\n    /*\r\n     * Store column names as an object\r\n     * with keys of Google-formatted \"columnName\"\r\n     * and values of human-readable \"Column name\"\r\n     */\r\n    loadPrettyColumns: function(data) {\r\n      var pretty_columns = {};\r\n\r\n      var column_names = this.column_names;\r\n\r\n      var i = 0;\r\n      var l = column_names.length;\r\n\r\n      for (; i < l; i++) {\r\n        if (typeof data.feed.entry[i].content.$t !== 'undefined') {\r\n          pretty_columns[column_names[i]] = data.feed.entry[i].content.$t;\r\n        } else {\r\n          pretty_columns[column_names[i]] = column_names[i];\r\n        }\r\n      }\r\n\r\n      this.pretty_columns = pretty_columns;\r\n\r\n      this.prettifyElements();\r\n      this.ready();\r\n    },\r\n    \r\n    /*\r\n     * Go through each row, substitutiting\r\n     * Google-formatted \"columnName\"\r\n     * with human-readable \"Column name\"\r\n     */\r\n    prettifyElements: function() {\r\n      var pretty_elements = [],\r\n          ordered_pretty_names = [],\r\n          i, j, ilen, jlen;\r\n\r\n      var ordered_pretty_names;\r\n      for(j = 0, jlen = this.column_names.length; j < jlen ; j++) {\r\n        ordered_pretty_names.push(this.pretty_columns[this.column_names[j]]);\r\n      }\r\n\r\n      for(i = 0, ilen = this.elements.length; i < ilen; i++) {\r\n        var new_element = {};\r\n        for(j = 0, jlen = this.column_names.length; j < jlen ; j++) {\r\n          var new_column_name = this.pretty_columns[this.column_names[j]];\r\n          new_element[new_column_name] = this.elements[i][this.column_names[j]];\r\n        }\r\n        pretty_elements.push(new_element);\r\n      }\r\n      this.elements = pretty_elements;\r\n      this.column_names = ordered_pretty_names;\r\n    },\r\n\r\n    /*\r\n      Return the elements as an array of arrays, instead of an array of objects\r\n    */\r\n    toArray: function() {\r\n      var array = [],\r\n          i, j, ilen, jlen;\r\n      for(i = 0, ilen = this.elements.length; i < ilen; i++) {\r\n        var row = [];\r\n        for(j = 0, jlen = this.column_names.length; j < jlen ; j++) {\r\n          row.push( this.elements[i][ this.column_names[j] ] );\r\n        }\r\n        array.push(row);\r\n      }\r\n      return array;\r\n    }\r\n  };\r\n\r\n  if(inNodeJS) {\r\n    module.exports = Tabletop;\r\n  } else if (typeof define === 'function' && define.amd) {\r\n    define(function () {\r\n        return Tabletop;\r\n    });\r\n  } else {\r\n    global.Tabletop = Tabletop;\r\n  }\r\n\r\n})(this);\r\n</script>\r\n<script>\r\ndocument.addEventListener('DOMContentLoaded', function() {\r\n        var URL= 'https://docs.google.com/spreadsheets/d/1do7tk5K9yhNlAx8wVda-4pU2hvGNF1D5AkgduLovcMw/pubhtml';\r\n        Tabletop.init( { key: URL, callback: convertToGeoJSON, simpleSheet: true } )\r\n}) \r\n\r\nvar geojson;\r\n\r\nfunction convertToGeoJSON(data) {\r\n \tconsole.log(data);\r\n\tplaces = []\r\n\tfor (i = 0; i < data.length; i++) {         \r\n       \r\n        places [i]= { \r\n        \t\t\t\"type\":\"Feature\",\r\n        \t\t\t\r\n        \t\t\t\"geometry\": {\r\n        \t\t\t\t\"type\":\"Point\", \r\n        \t\t\t\t\"coordinates\": [\r\n        \t\t\t\t\tparseFloat(data[i].Lng),parseFloat(data[i].Lat)\r\n        \t\t\t\t\t]\r\n        \t\t\t},\r\n        \t\t\t\"properties\":{\r\n        \t\t\t\t'title': 'suppo',\r\n        \t\t\t\t'description': 'hi',\r\n        \t\t\t\t'marker-size': 'large',\r\n        \t\t\t\t'marker-color': '#0000FF',\r\n        \t\t\t\t'marker-symbol': data[i].Icon,\r\n        \t\t\t}\t\r\n       \r\n }\r\n }\r\n \r\n \r\n \r\n       geojson = {\r\n       type: \"FeatureCollection\",\"features\": places}\r\n        \r\n        setupMap(geojson);   \r\n}\r\n\r\n\r\nfunction setupMap(geo) {\r\n        myLayer.setGeoJSON(geo);\r\n    }\r\n    \r\n\r\n\t\r\n\r\n</script>\r\n\r\n</body>\r\n</html>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}